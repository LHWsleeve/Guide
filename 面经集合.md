# 2019 春招面经大集合

[toc]

collabedit 写代码

## **1.算法**

- 以 O(1)时间复杂度取得最小值的栈，要求有 pop push getMin 方法
- 反转数组（代码）
- 排序的时间复杂度，空间复杂度，稳定性
- 排序的原理（快排，归并，堆）
- 散列，冲突处理方法
- 实现 LRU 算法/FIFO--[LinkedHashMap](\Container/LinkedHashMap.md#%e5%88%a9%e7%94%a8linkedhashmap%e5%ae%9e%e7%8e%b0lru%e7%bc%93%e5%ad%98)
- topk 问题思路(堆，几个 top 就扔几个进堆)
- 查找手写
- 爬虫生成的 8G 的 URL 文件，只有 1G 的内存，如何查找出重复的 URL(分布式 Hash-->一致性哈希)--==**布隆过滤器**==
- 四则运算（提示使用栈）
- 判断链表是否有环？单指针方法--判断环的入口-->==相交数组的成环问题==
- 第一题，遍历 list，并删除指定元素，（想考我 foreach 的坑，但是我没接招，使用迭代器完成，fail-fast）
- 手写死锁
- 实现优先队列

## **2.网络：**

- HTTP 方法/协议状态码---`HTTP幂等性及GET、POST(非幂等)、PUT(幂等)、DELETE的区别和有无幂等性`---`HTTP缓存机制`---`既然说 HTTP 是无状态的，那服务器怎么记住上次请求的用户`---`http 安全问题`---`https 如何实现`
- 幂等性设计：大型网站技术构架 P78
- [restful](https://www.zhihu.com/question/28557115)
- [TCP 协议的 TIME_WAIT 状态详解](https://blog.51cto.com/11859650/1917938)
- 三次握手，四次挥手/tcp 和 udp 的区别
- TCP 协议拥塞--网络层的滑动窗口协议---TCP/IP 的五层协议模型和 OSI 的七层协议模型了解么？简单说一下，TCP 协议在哪一层？
- [DNS 实现的机制](https://juejin.im/post/5b0a32a36fb9a07ab979f0b4)
- [TCP 怎么保证可靠传输](https://zhuanlan.zhihu.com/p/104929583)

## **3.Java 基础**

- 集合类遍历时是否可以修改（不可以，fail-fast）---`如果我非要修改呢（CopyonWriteArrayList可以在遍历的时候修改）`[https://blog.csdn.net/sinat_35821285/article/details/80226019]
- [String 是怎么扩容的（不知道，后来查的：2 倍扩容，超出 1M 后每次扩大 1M）](https://www.jianshu.com/p/100ad9b44a71)
- ArrayList 和 LinkedList 的区别
- Java 泛型(920 P108)
- 如何实现 hashmap 的只读不可写，不采用其他工具--[https://blog.csdn.net/codejas/article/details/78688925]
- this 关键字--super 与 this 异同[https://www.nowcoder.com/discuss/179581]
- [main 方法中 String[] args 为什么要使用 String？main 方法的返回值为什么是 void](https://blog.csdn.net/qq_39525442/article/details/89343343)？
- int,double,float 长度（其实等于 java 为什么跨平台）
- [四类八种基础数据类型及其包装类](https://zhuanlan.zhihu.com/p/25439066)，装箱拆箱--从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是 Integer 的 valueOf(int)方法。而在拆箱的时候自动调用的是 Integer 的 intValue 方法。
- Integer 的缓存机制
- object 的方法
- Java Collection-容器---`容器的一个接口路线，从iterator往下，两个，一个map,一个Collection，map下面的hashmap，treemap,Collection下面的list,Set。list下面的ArrayList和LinkedList,Set下面的hashSet和TreeSet等，之后再吹了一下迭代器的快速失败和安全失败`
- 为什么链表大于 8 的时候转成红黑树；
- 异常你了解吗？有哪些
- 面向对象三大特征---`介绍多态`-**所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性**。
  如果向上转型--子类中父类没有的，不能调用；父类有的(重写方法)会被多态绑定到子类的方法上。

```html
对于多态我们可以总结如下：
指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。
若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。
对于面向对象，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，
通过编译之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。
```

- [抽象类和接口](https://zhuanlan.zhihu.com/p/56789932)
- Java 中类变量和成员变量，类方法和成员方法
- [treemap 底层数据结构，扩容，插入删除效率](https://www.jianshu.com/p/2dcff3634326)
- ※HashMap 源码级别的原理，rehash 是什么---`Hashmap的缩容，扩容机制`---`位运算的好处`---`hashmap和hashtable区别,模运算比较`---`为什么使用红黑树`
- [Java 中的 NIO](https://zhuanlan.zhihu.com/p/115715326)
- IPC 方式[进程间通信方式](https://www.jianshu.com/p/c1015f5ffa74)
- [请求 servlet 的过程](https://www.jianshu.com/p/746a57e47129)-[servlet 的生命周期](https://juejin.im/post/5c160422e51d45453c1cdc30)
- [反射机制](https://www.jianshu.com/p/5110834f669f)( 920 P104)
- [注解是什么](https://juejin.im/post/5b45bd715188251b3a1db54f)
  ```markdown
  注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成
  的动态代理类。我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象。
  通过代理对象调用自定义注解的方法，会最终调用 AnnotationInvocationHandler 的
  invoke 方法。该方法会从 memberValues 这个 Map 中索引出对应的值。而 memberValues的来源是 Java 常量池。
  ```
- ==StringBuilder 和 StringBuffer//String== [为什么设计成 final 不可变](https://juejin.im/post/5aa1ee0c51882555677e2109)？ 是怎么实现不可变的
- static 用法
- [Java 内部类为什么能够访问外部成员变量](https://www.jianshu.com/p/3132b0641883)--[内部类能否引用外部类的 private 成员](https://www.zhihu.com/question/54730071)（**被 private 修饰的内部类只能在它所属的外部类中访问**）
- [Java 的继承有什么缺点](https://www.zhihu.com/question/20128211)
- i++线程安全吗
- equals 和 hashcode 为什么要一起重写。一个类，如果重写了 Equals(),不重写 HashCode()，会有什么问题（==重写 hashcode()，主要是针对映射相关的操作（Map 接口，依靠具体值生成 hashcode）==，仅仅重载 equals 方法可能会导致实际业务逻辑失败，确保 equals 相同 hashcode 也相同，即保证相同对象的 hashcode 一定相同）
- [类加载方式，以及区别](https://blog.csdn.net/obession/article/details/78247165)

### **3.1 并发**

- [详细论述几个并发容器](https://juejin.im/post/5d63c7a96fb9a06b2116f5e0)
- juc---`多线程和JUC熟悉吗，我说了AQS、ReentrantLock、线程池、CountDownLatch、CyclicBarrier，然后问了我AQS是什么`---concurrent 包下有哪些常用的类--- `concurrenthashmap，原理/JDK8 的变化`
- 哪些原子性操作--JUC 下 Atomic（Ladder） 包
- 怎么实现 A、B、C 三个线程轮流打印
- ==什么是线程池？线程池的参数？线程池的工作原理？线程池的种类？任务拒绝策略？==
- 线程数设置多大，如果超过了最大的怎么办，有哪些==拒绝策略==，如果抛出异常怎么处理
- 代码执行单元是？（线程）---是线程还是进程申请资源？（进程）--Java 线程状态
- ==Java 中的线程安全==-`线程实现的方式`---`继承Thread类和实现Runale接口`---`进程和线程的区别`---`sleep和wait区别`---`threadlocal`---`start和run方法的区别，什么方法开启线程`---`进程间通讯的方式(后台开发.pdf)`------`各种线程池的应用场景`---`java的线程和操作系统的线程`---`有时候会采用一种无锁化机制去线程同步，有哪些方案`
- [自旋锁 是公平吗？ 自旋锁 怎么才能公平](https://blog.csdn.net/Holmofy/article/details/75213405)
- 线程池大小如何设置？ 线程数设置过大有什么缺点？
- **阻塞队列以及生产者消费者的实现**
- sleep会让出cpu资源(每一次唤醒都会内核态和用户态切换)，不会让出锁资源。wait会让出锁和cup资源
- [Java线程模型](https://juejin.im/post/6844903957664366600)

### **3.2 JVM 是重点**

- 画一下 Java 的内存模型(**Java 内存模型来屏蔽掉各种硬件和操作系统的内存访问差**)
- Java 内存区域模型
- 栈和堆--[为什么要划分为堆和栈](https://www.zhihu.com/question/49927441)
```html
因为结构化语言里函数（子程序）调用最方便的实现方式就是用栈，以至于现在绝大部分芯片都对栈提供芯片级的硬件支持，一条指令即可搞定栈的pop操作。
栈的好处是：方便、快、有效避免内存碎片化。
栈的问题是：不利于管理大内存（尤其在16位和32位时代）、数据的生命周期难于控制（栈内的有效数据通常是连续存储的。
所以pop时后申请的内存必须早于先申请的内存失效），所以栈不利于动态地管理并且有效地利用宝贵的内存资源。于是我们有了堆。
```
- 四种引用类型
- final 关键字底层原理，为什么做到了不可变。--实际上可以使用反射改变
- [volatile 底层原理](http://xianzilei.cn/blog/60)
- [CPU 总是 100%，怎么定位问题，并且解决](https://juejin.im/post/5c21f381518825438f6bb553)---`CPU 时而 100%，内存经常 100%，怎么定位问题，并且解决`---==linux 常见命令==
- ==详细论述 JVM 的垃圾垃圾回收机制==--`GC算法`---`常见的垃圾回收器及他们之间区别，垃圾回收发生在哪里`---`JVM调优命令`---`新生代老年代大小如何划分`---`怎么避免产生浮动垃圾？`
- gcroot 对象有哪些
- 锁机制极其重要 ---`CAS原理/内存可见性/问题`---`※synchronized 锁静态方法和普通方法区别，volitile 关键字的理解`---`lock和synchronized区别`---`栅栏和闭锁的区别`---`锁类型（尤其自旋锁）`
- ==Java 的内存模型-8 个指令==--`java中变量存储的位置`
- 双亲委派模型 本质/用处
- 有几种类加载器
- Java [内存泄漏如何排查排查](https://juejin.im/post/5d0ae117f265da1bc64bc7d7#heading-0)
- JVM 虚拟机启动是单线程的还是单进程的？
- [`.Class, Class.forName, .getClass()`的区别](https://blog.csdn.net/u013160932/article/details/41861881)
```html
1.类名.class==clasloader
JVM将使用类装载器，将类装入内存(前提是:类还没有装入内存)，不做类的初始化工作，返回类的Class对象。
2.Class.forName(String className)
做类的静态初始化，返回类的Class对象。（ 如果使用Class.forName(String name, boolean initialize,ClassLoader loader) ，并将initialize的值设为false，则不会进行类的静态初始化）
3.object.getClass()
对类进行静态初始化、非静态初始化（由于首先使用new得到类的实例对象，实际上是这一步对类进行了初始化）;返回引用运行时真正所指的对象(子对象的引用会赋给父对象的引用变量中)所属的类的Class的对象。
```
- [JVM字节码执行引擎](https://juejin.im/post/6844904116007731213)

## **Java 框架**
- [SpringMVC controller是否是线程安全的。不安全，那怎么解决？](https://blog.csdn.net/qq_32575047/article/details/78997488)
- servlet --`生命周期/怎么响应浏览器请求`--`浏览器输入一个地址到看到返回内容中间流程`---`dispatcher流程`--`输入一个url，具体到每一个层`
- ==Spring---IOC/DI/AOP==---`AOP有哪几种实现`---`单实例无状态`
- MVC 是什么-`springmvc里session和cookie/区别/联系？`
- springboot 与 springMVC 有什么区别--- SpringBoot 的自动配置流程
- springMVC 执行过程---SpringMVC 中用到了哪个核心的 Servlet ?
- spring bean 的生命周期---Spring 里面有哪些核心的特性？---Spring 注入的方式有哪些？---Spring 的 scope 里面有哪几个属性？bean 成员变量的参数注入有哪种方式？
- [除了@ResponseBody，controller 层如何标准返回给前端所要的数据类型？](http://www.zuidaima.com/question/2394426140756992.htm)
- @resource和@autowired的区别
```html
 1）处理这2个注解的BeanPostProcessor不一样CommonAnnotationBeanPostProcessor是处理@ReSource注解的AutoWiredAnnotationBeanPostProcessor是处理@AutoWired注解的  
（2）@Autowireds首先按照byType 注，如果存在两个再根据name找入；@Resource默认按byName自动注入，也提供按照byType 注入；
（3）属性：
@Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。
@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。
需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。@Resource装配顺序　　
1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常　　
2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常　　
4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；
```
- [spring boot 启动流程](http://java.isture.com/spring/SpringBoot/SpringBoot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.html)
- [聊聊服务的注册与发现](https://juejin.im/post/5efc4d3f5188252e494138d0)
- [注册中心挂掉怎么办](https://zhuanlan.zhihu.com/p/111170265)
- Spring如何进行事务控制
```txt
Spring事务包括编程式事务和声明式事务。在系统使用了声明式的事务管理是用Spring的AOP来实现的；配置了只读事务和回滚事务（传播行为REQUIRED）当出现错误后进行回滚操作。在项目中通过aop切入事务到 serivce层，这样做能使一次业务逻辑操作如果包括几个数据库操作都控制在一个事务中。
```
- [Spring循环依赖](https://mp.weixin.qq.com/s?__biz=MzU5ODg2Njk4OA==&mid=2247484390&idx=1&sn=b469cde5f32e9eb8c92345e6fd34f688&chksm=febceea5c9cb67b326c2095c954b0b95f1fb9373d51e7197bb46267a7dd162df37c4cc723543&mpshare=1&scene=23&srcid=0727OwmDe0NGVMHZl6Fxc3t3&sharer_sharetime=1595836373144&sharer_shareid=8bb087acd66607d2af6ea8935f9a4681#rd)==spring默认按照bean顺序先后加载，如果第一个加载的是构造器注入则一定不成功，暴露的前提是需要这个类实例化，构造器方式，A(B)，无法将A实例化。而setter方式先执行A()无参构造器，暴露实例，然后注入==
- Spring 事务以及传播机制

## **数据库**
- [为什么InnoDB表必须有主键，并且推荐使用整形的自增主键？](https://zhuanlan.zhihu.com/p/71022670)
- [介绍下 JDBC 的过程 /JDBC 的 Statement 对象有哪几类 ](https://www.jianshu.com/p/187c7f796b18)
- [mysql 的三级封锁协议](https://www.jianshu.com/p/0b4cc2802f6b)
- [怎么优化 mysql，mysql 性能分析工具](https://www.kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie)---`mysql的查询优化，用explain查询是否用到了索引`
```html          
原理，SQL语句在程序运行前已经进行了预编译，在程序运行时第一次操作数据库之前，SQL语句已经被数据库分析和编译，对应的执行计划也会缓存下来，之后数据库就会以参数化的形式进行查询。印象里mysql的preparedStatement方法继承并实现了setString方法，会把字符串转义，如果是不合法的sql是无法执行的。
```
- JDBC 连接 mysql 的几个步骤、为什么要加载驱动呢，原理是什么、PreparedStatement 和 Statement 区别、返回结果如何查询
- ==[MySQL 的锁机制](https://juejin.im/post/5b82e0196fb9a019f47d1823#heading-1)==---悲观锁和乐观锁呢？悲观和乐观锁的具体实现原理呢？
- ==Mybatis 底层实现==---`一二级缓存，#和\$的区别`

```markdown
使用#{}意味着使用的预编译的语句，即在使用 jdbc 时的 preparedStatement，sql 语句中如果存在参数则会使用?作占位符，我们知道这种方式可以防止 sql 注入，并且在使用#{}时形成的 sql 语句，已经带有引号，例，selectfrom table1 where id=#{id}
在调用这个语句时我们可以通过后台看到打印出的 sql 为：select \* from table1 where
id='2' 加入传的值为 2.也就是说在组成 sql 语句的时候把参数默认为字符串。</br>

使用${}时的sql不会当做字符串处理，是什么就是什么，如上边的语句：select * from
table1 where id=${id} 在调用这个语句时控制台打印的为：select _ from table1 where
id=2 ，假设传的参数值为 2
从上边的介绍可以看出这两种方式的区别，我们最好是能用#{}则用它，因为它可以防止 sql 注入，且是预编译的，在需要原样输出时才使用\${}，如，
select _ from ${tableName} order by ${id} 这里需要传入表名和按照哪个列进行排序
，加入传入 table1、id 则语句为：select _ from table1 order by id 如果是使用#{}
则变成了 select _ from 'table1' order by 'id' 我们知道这样就不对了。

为什么预编译可以解决 SQL 注入。在我理解，预编译就是按照已有的关键字对 sql 进行编译，
只留下一些坑位填充，坑位作为字符串填充直接执行，而不会重新作为整个 sql 编译。从而避免某些注入行为。
```

- MVCC 机制的实现原理
  ```html
  多版本并发控制指的就是在使用 READ COMMITTD、REPEATABLE READ 这两种隔离级
  别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事
  务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ
  这两个隔离级别的一个很大不同就是生成 ReadView 的时机不同，READ COMMITTD 在每
  一次进行普通 SELECT 操作前都会生成一个 ReadView，而 REPEATABLE READ 只在第一
  次进行普通 SELECT 操作前生成一个 ReadView，之后的查询操作都重复这个 ReadView
  就好了
  ```
- 数据库的隔离级别
- 数据库范式
- mysql 存储引擎以及适用场景 innodb 和 myisam 的区别？
- ==数据库的索引==---`如何建索引`---`索引失效`---`索引底层实现是什么`
- 聚簇索引和非聚簇索引

  ```html
  聚簇索引和非聚簇索引的根本区别：聚簇索引（innodb）的叶子节点就是数据节点而非聚簇索引（myisam）的叶子节点仍然是索引文件只是这个索引文件中包含指向对应数据块的指针。
  B+树有主键索引和辅助索引两种:主键索引就是按照表中主键的顺序构建一颗
  B+树，并在叶节点中存放表中的行记录数据，一个表只能有一个主键索引。而辅助索
  引，叶节点并不存储行记录数据，仅仅是主键。通过辅助索引查找到对应的主键，最
  后在聚集索引中使用主键获取对应的行记录。（这个叫回表查询）
  ```

---除开使用 B+ 树实现的索引，还了解其他数据结构实现的索引吗--[为什么不使用 AVL/红黑树](https://www.cnblogs.com/aspirant/p/9214485.html)(920P64)

```html
因为普通的全表查询时间复杂度是 O(n);如果是平衡二叉树，或者红黑树，查找时间变 成
O(log2N)，但他们依然不适合做索引。因为索引通常比较大，存于磁盘中，无法一
次将全部的索引加载到内存中，每次只能从磁盘中读取一个页到内存中，而平衡二叉树
底层实现是数组，逻辑上相邻的节点在物理结构上可能相差很远，因此磁盘 IO 次数可
能很大，平衡二叉树没能充分利用磁盘预读功能。磁盘往往不是严格按需读取，而是每
次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长
度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理。 红黑树这
种结构，h 明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用
局部性，所以红黑树的 I/O 渐进复杂度也为 O(h)，效率明显比 B-Tree 差很多。
B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用
了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着
非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常
少，更多的是在内存中对读取进来的数据进行查找。
```

- [以 B tree 和 B+ tree 的区别来分析 mysql 索引实现](https://www.jianshu.com/p/0371c9569736)
- 事务的特性---`什么是事务 事物的几种特性 如何理解 mysql事务隔离级别`---[事务的二段提交](https://www.jianshu.com/p/765b5a3dac15)
- 为什么 Mysql 索引要用 B+树不用别的数据结构
- MySQL 外键删除策略
- [MySQL 分库分表的方案](https://juejin.im/entry/5b5eb7f2e51d4519700f7d3c)
- SQL 语句 exist 和 in 的区别
- [SQL 语句怎么执行的知道吗，底层原理是什么](https://segmentfault.com/a/1190000015979741)
- 姓名、科目、成绩，写 sql 语句统计总分前三的学生姓名，如果有并列的怎么办？统计这个班的学生选了哪些科目
- 时序数据库与常用的 mysql 有什么区别
- 组合索引吗？怎么实现的？
-[ 分页原理--、limit 分页为什么慢，怎么优化](https://www.cnblogs.com/june0816/p/6757383.html)
- .mysql cpu 过高怎么排查呀（不会，面试官说可以用 error log 看下）
- mysql 处理死锁的方式？`1、等待，直到超时，事务自动回滚。2、发起死锁检测， 回 滚一个事务，让其他事务执行`
- [Explain 语句的字段](https://juejin.im/post/5ec4e4a5e51d45786973b357?utm_source=gold_browser_extension)
- SQL 优化 (920-P77)
- mysql 主从复制存在的问题--主从复制的复制延迟怎么解决？
- 缓存机制，一级、二级原理和作用

  ```html
  mybatis 的查询缓存分为一级缓存和二级缓存，一级缓存是 SqlSession 级别的缓存，
  二级缓存是 mapper 级别的缓存，二级缓存是多个 SqlSession 共享的;
  当在同一个SqlSession 中执行两次相同的 sql 语句时，第一次执行完毕会将数据库中
  查询的数据写到缓存（内存）中，第二次查询时会从缓存中获取数据，不再去底层进行
  数据库查询，从而提高了查询效率。如果 SqlSession
  执行了DML操作（insert、update、 delete），并执行
  commit（）操作，mybatis则会清空SqlSession 中的一级缓存,避免 脏读现象。 Mybatis
  的二级缓存是Mapper级别的缓存，默认不开启，需手工配置。其存储作用 域为
  Mapper，也就是同一个namespace 的 mappe.xml; 当一个 sqlseesion 执行了一
  次select 后，在关闭此session
  的时候，会将查询结果缓存到二级缓存。当另一个sqlsession
  执行select时，首先会在他自己的一级缓存中找，如果没找到，就回去二级缓存中找，找到了就返回，就不用再去数据库了。
  ```

  - [mysql 索引失效](https://www.jianshu.com/p/932bcdf2c89f)这里少..比较详细的因该在<XX 书里面>
  - 使用like匹配的时候，会不会查询非常慢
  - [慢查询日志以及配合explain及逆行慢查询优化和分析](https://juejin.im/post/5e108a55f265da5d5537fe11#heading-14)
  - [union和union all的区别](https://juejin.im/post/5c131ee4e51d45404123d572)
  - [mysql怎么实现可重复读](https://juejin.im/post/6844904180440629262)
  - [选课系统设计](https://wenku.baidu.com/view/4958a18a84868762caaed521.html)
## **设计模式**

- 简单工厂抽象工厂
- 观察者模

## **分布式**

- [分布式哈希的实现-->一致性哈希(介绍一致性哈希)](https://www.jianshu.com/p/6ad87a1f070e)-`服务器挂了，数据会丢失吗`
  ```html
  1. 一致性哈希是实现分布式哈希的一种算法，
  2. 一致性哈希算法中，整个哈希空间是一个圆环，圆环上存在N个物理机，经过哈希函数映射到圆环上并且存储再顺时针第一个物理机上。
  3. 优点：二分查找可以很快查询到物理机上的数据，如果某个服务器宕机，只会影响两个物理机区间的数据，并且数据会转移到下一个物理集中存储。有很好的扩容性。
  4. 缺点:数据倾斜。如果在集群中，节点太少，并且分布不均，一致性哈希算法就会出现部分节点数据太多，部分节点数据太少的情况。--引入虚拟节点机制，对每一个物理机都生成N个虚拟节点，理论上虚拟节点越多数据平衡性越好。
  ```
- 分布式锁？分布式锁如何实现
- 负载均衡的策略
- 分布式环境做线程同步
- 分布式 rpc 调度过程中要注意的问题
- 介绍下 HDFS

## **Linux**

- Linux 的常见命令
- select poll 和 epoll 的区别
- Linux 下打开超大文件方法
- linux 下怎么查看一个端口有没有被占用
- linux 的异常退出状态码

## 以下基本是项目里涉及
- 用过哪些日志框架、日志框架间的比较？
- 道哪些 RPC 的方式？有哪些框架？如果让你设计 RPC 数据交换报文格式你会怎么设计？
- 说一下你对高并发的理解
- 如何理解代码规范（阿里巴巴代码规范）
- tomcat 的配置参数有印象吗？优化方面有了解过吗
- 项目中异步化怎么实现的
- jar 包冲突
- sql 里加锁
- Nginx 负载均衡策略---`nginx 是如何实现反向代理`-----`nginx下面有A，B俩系统，如果访问完A后再访问B，B怎么知道（如何实现无密码登陆）`
- 大数据判重
  只有一台机器，数据是 int 范围，给了 3 个思路，一个是 hash 切分大文件为小文件，对小文件用 hashset 去做判重，还有用 BitSet，单机大概 500mb 内存可以解决，最后一个是用布隆过滤器解决，内存利用更小。 然后问我布隆过滤器的误差怎么解决，我说可以加大 hash 数量或者 hash 的范围，还有可以用多个独立的不同的布隆过滤器来解决。
- 跨站脚本攻击 XSS
- 十亿数量，乱序，怎么快速找到中位数
- 服务器怎么做到高可用？怎么保证稳定性
- 影响服务器接收请求数量的因素有哪些？
- I/O 模型五种详解
- 单点登录?看到两次，不知道是啥
- 项目中秒杀流程
- Ajax 是什么，Ajax 实现原理
- 索引分析，索引失效。
- 微服务理解，如何划分
- 分布式的调用有了解吗（远程服务调用）
- 支付宝到银行的转账业务怎么实现
- [减库存然后下订单，但是服务器宕机？](https://blog.csdn.net/qq_41649078/article/details/91492383?utm_medium=distribute.pc_relevant_right.none-task-blog-BlogCommendFromBaidu-2.nonecase&depth_1-utm_source=distribute.pc_relevant_right.none-task-blog-BlogCommendFromBaidu-2.nonecase)

## **eureka**

- 底层原理 gixn 负载均衡的算法有哪些

## **Redis**

- ※Redis 有哪些数据结构 920 p79
- Redis 持久化方式
- [rdb做持久化的时候，将内存中的数据复制到磁盘中时，怼redis的读写会受到影响吗?](https://juejin.im/post/6844903886189395982#heading-2)
- AOF过大怎么办？AOF压缩是怎么实现的？
- 如何保证缓存和数据库双写时的数据一致性？(920 P83)
- 缓存的实现方式
- Redis 的缓存淘汰策略有哪些
- [redis 怎么保证原子性](https://www.jianshu.com/p/f42d5f5c495b)
- [redis 是单线程的为什么要上锁](https://www.zhihu.com/question/294599028)
- [Redis 的并发竞争问题如何解决？ ](https://blog.csdn.net/jason1993as/article/details/86850772?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase)
  - memcache 实现分布式锁
  - redis 实现分布式锁。
  - zookeeper 实现分布式锁。
- redis 分布式锁的问题？
- Redis 的跳表--何使用跳表不使用 B+树做索引
- key 的写入和删除的原理
- [怎么保证 Redis 的高可用---redis 怎么处理高并发，几种思路](https://www.jianshu.com/p/b9afe686e307)= Redis 一主多从的实现？如果主服务器挂了怎么办？能锁住吗

- [问 Redis 为什么快，我答内存数据库、单线程、](https://blog.csdn.net/u010638913/article/details/90475536?utm_medium=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-12.nonecase&depth_1-utm_source=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-12.nonecase)(920 P84)
  更喜欢这个答案(https://blog.csdn.net/diweikang/article/details/90264993)
- [IO 多路复用](https://www.zhihu.com/question/28594409)
- [SDS 优点，链表、跳表的实现与复杂度 ](https://blog.csdn.net/wwxy1995/article/details/99719259)
- [如何保证 redis 中的都是热点数据==Redis 过期策略](https://blog.csdn.net/weixin_39590058/article/details/105217804)
- [Redis 有哪些弊端](https://www.jianshu.com/p/929bc7ee8063)
- list [如何实现的异步消息队列](https://juejin.im/post/5cee4f59f265da1bb679faef)？
- 集群是如何判断是否有某个节点挂掉/集群进入 fail 状态的必要条件： 920 p92
- [何使用跳表不使用 B+树做索引](https://www.cnblogs.com/aspirant/p/11704530.html)
- redis 的长尾效应--- 冷热分区，小而热的数据，内存，大而冷的数据-磁盘，大而热的数据-SSD 或者，对于长尾访问的数据、大多数数据访问频率都很高的场景、缓存空间足够都可以考虑不过期缓存，比如用户、分类、商品、价格、订单等，当缓存满了可以考虑 LRU 机制驱逐老的缓存数据。

- [redis 的大 Key 问题](https://www.jianshu.com/p/c934ddbdd5de)
- redis key 和 value 的大小限制---redis 的 key 和 string 类型 value 限制均为 512MB。
- [Redis 的三种集群模式，主从，集群，哨兵](https://zhuanlan.zhihu.com/p/145186839)
- 为什么用redis(一开始我们使用redis做一个消息队列，发布订阅模式广播..)
- Redis如何实现延时队列？
```
1.使用list来实现延迟队列，+休眠+blpop和brpop。
2. 使用zsort，使用时间戳做score（排序）, 有序集合的value设置为我们的消息任务，把value的score设置为消息的到期时间，然后轮询获取有序集合的中的到期消息进行处理。
又产生了一个问题，同一个任务可能会被多个进程取到之后再使用 zrem 进行争抢，那些没抢到的进程都是白取了一次任务，这是浪费。
解决办法：将 zrangebyscore和zrem使用lua脚本进行原子化操作,这样多个进程之间争抢任务时就不会出现这种浪费了。

实时性: 允许存在一定时间内的秒级误差
高可用性:支持单机,支持集群
支持消息删除:业务费随时删除指定消息
消息可靠性: 保证至少被消费一次
消息持久化: 基于Redis自身的持久化特性,上面的消息可靠性基于Redis的持久化,所以如果redis数据丢失,意味着延迟消息的丢失,不过可以做主备和集群保证;
```



## **RabbitMQ**

- 消息中间件的好处(解耦-降低延迟提升响应速度。
  我们这个项目的业务体量很小，所以一开始是直接redis作为缓存中间层，然后使用redis的发布订阅模式(广播)一把整完。使用MQ主要三个原因，一是项目范围扩大，拆分了很多的服务，业务场景越来越复杂了。二是我们做到中期的时候西奥他们厂子说要扩建生产线，原先结构担心承压不住，三，是redis无论怎么做都存在消息丢失问题，该方案消息的状态过于简单(没有状态)，且没有ack机制，消息取出后消费失败依赖于client记录日志或者重新push到队列里面，然后好巧不巧我们做测试的那个把星期他们公司内网贼差，丢了好多回数据。最后我们一合计...干脆就用消息队列了。
  
  异步，削峰)
- rabbitMQ 是怎么保证消息不丢失
- rabbitmq 能避免发送重复数据吗
- [RabbitMQ和其它消息队列，比如ActiveMQ，RocketMQ，Kafka有什么区别](https://www.javazhiyin.com/25567.html)
  ![](java10-1547173403.jpg)

![](assserts/8.png)
![](assserts/9.png)
![](assserts/10.png)
![](assserts/11.png)
## 操作系统
- 什么是僵尸进程？
- 有什么危害？怎么处理

## 精华面经

秋招简单介绍![https://www.nowcoder.com/discuss/317888]
快手 java[https://www.nowcoder.com/discuss/179560](快手java)
详细带解析 [https://www.nowcoder.com/discuss/171371]
招银总结![https://www.nowcoder.com/discuss/166431]
详细的阿里腾讯头条啊![https://www.nowcoder.com/discuss/342084]
※面试问题解析![https://www.nowcoder.com/discuss/323173][字节大佬](https://www.nowcoder.com/discuss/444569?toCommentIpt=1)

## 神奇项目大佬的面试

netty 通信的简易 rpc 调用框架：
![](assserts/1.png)
![](assserts/2.png)
![](assserts/3.png)
![](assserts/4.png)
![](assserts/5.png)
![](assserts/6.png)
![](assserts/7.png)
